import xml.etree.ElementTree as ET
import re
from xml.dom import minidom

def inject_schedule_for_producer(producer_xml_string, schedules_xml_string):
    """
    Injects a matching <SCHEDULE> block from schedules_xml_string into the producer_xml_string
    after the </Consumers> tag. Pretty-prints the final output, preserving all CDATA sections.
    """

    # Step 1: Parse the producer XML and extract scux_USER_ID
    try:
        root = ET.fromstring(producer_xml_string)
    except ET.ParseError:
        return producer_xml_string  # Return original if parse fails

    # Detect namespace if any
    ns_match = re.match(r'\{(.*)\}', root.tag)
    ns = {'ns': ns_match.group(1)} if ns_match else {}

    # Find user ID
    user_elem = root.find('.//ns:scux_USER_ID', ns) if ns else root.find('.//scux_USER_ID')
    if user_elem is None or not user_elem.text:
        return producer_xml_string
    user_id = user_elem.text.strip()
    expected_mailbox = f"/{user_id}"

    # Step 2: Find the matching <SCHEDULE> block from raw schedules XML
    schedule_blocks = re.findall(r"<SCHEDULE\b.*?</SCHEDULE>", schedules_xml_string, re.DOTALL)
    matched_schedule = None
    for sched in schedule_blocks:
        cdata_match = re.search(
            r"<SCHEDULE_PARAMS><!\[CDATA\[(.*?)\]\]></SCHEDULE_PARAMS>", sched, re.DOTALL
        )
        if not cdata_match:
            continue
        if f"<Name>ProducerMailbox</Name><Value>{expected_mailbox}</Value>" in cdata_match.group(1):
            matched_schedule = sched
            break

    if not matched_schedule:
        return producer_xml_string  # No match found

    # Step 3: Pretty-print the producer XML (excluding schedule)
    rough_string = ET.tostring(root, encoding="utf-8")
    pretty_xml = minidom.parseString(rough_string).toprettyxml(indent="  ")

    # Step 4: Inject the raw <SCHEDULE> block after </Consumers>
    injection_point = "</Consumers>"
    if injection_point not in pretty_xml:
        return producer_xml_string  # Injection point not found

    updated_xml = pretty_xml.replace(injection_point, f"{injection_point}\n{matched_schedule}")
    return updated_xml
