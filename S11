import re
import xml.etree.ElementTree as ET
from xml.dom import minidom

# Correct namespace
SI_NS = "http://www.stercomm.com/SI/SI_IE_Resources"
SI = f"{{{SI_NS}}}"

def extract_producer_mailbox_id(producer_xml_string: str) -> str:
    """Extract the value of <scux_USER_ID> from producer XML."""
    root = ET.fromstring(producer_xml_string)
    user_id_el = root.find(".//scux_USER_ID")
    if user_id_el is None or not user_id_el.text:
        raise ValueError("scux_USER_ID not found in producer XML")
    return user_id_el.text.strip()

def extract_schedule_for_mailbox(schedules_xml_string: str, mailbox_id: str) -> str:
    """Find matching <SCHEDULE> block from schedules XML for a given mailbox_id."""
    schedules_root = ET.fromstring(schedules_xml_string)
    for sched_el in schedules_root.findall(f".//{SI}SCHEDULE"):
        sched_params_el = sched_el.find(f"{SI}SCHEDULE_PARAMS")
        if sched_params_el is None or not sched_params_el.text:
            continue
        cdata = sched_params_el.text.strip()
        match = re.search(r"<ProducerMailbox>\s*(.*?)\s*</ProducerMailbox>", cdata)
        if match:
            full_mailbox = match.group(1).strip()
            short_id = full_mailbox.strip("/").split("/")[0]
            if short_id == mailbox_id:
                # Return the full <SCHEDULE> tag string
                schedule_str = ET.tostring(sched_el, encoding="unicode")
                return schedule_str
    raise ValueError(f"No matching schedule found for ProducerMailbox '{mailbox_id}'")

def inject_schedule_for_producer(producer_xml_string: str, schedules_xml_string: str) -> str:
    """Injects the matching <SCHEDULE> into the producer XML after <Consumers>."""
    mailbox_id = extract_producer_mailbox_id(producer_xml_string)
    schedule_block = extract_schedule_for_mailbox(schedules_xml_string, mailbox_id)

    # Locate injection point in the producer XML (after </Consumers>)
    injection_point = "</Consumers>"
    idx = producer_xml_string.find(injection_point)
    if idx == -1:
        raise ValueError("</Consumers> tag not found in producer XML")

    # Insert schedule block with newline
    updated_xml = (
        producer_xml_string[: idx + len(injection_point)]
        + "\n" + schedule_block
        + producer_xml_string[idx + len(injection_point):]
    )

    return pretty_print_xml(updated_xml)

def pretty_print_xml(xml_string: str) -> str:
    """Pretty print XML string preserving CDATA and formatting."""
    try:
        dom = minidom.parseString(xml_string)
        return dom.toprettyxml(indent="  ")
    except Exception:
        # Fallback to raw if pretty fails
        return xml_string
