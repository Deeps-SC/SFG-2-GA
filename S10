import xml.etree.ElementTree as ET
import re
from xml.dom import minidom

SI_NS = "http://www.stercomm.com/SI/SI IE Resources"
ET.register_namespace('', SI_NS)

def inject_schedule_for_producer(producer_xml_string: str, schedules_xml_string: str) -> str:
    # Parse producer XML
    prod_tree = ET.ElementTree(ET.fromstring(producer_xml_string))
    prod_root = prod_tree.getroot()

    # Extract producer ID from <scux_USER_ID>
    producer_id_elem = prod_root.find('.//scux_USER_ID')
    if producer_id_elem is None or not producer_id_elem.text:
        raise ValueError("scux_USER_ID not found in producer XML")
    producer_id = producer_id_elem.text.strip()

    # Parse schedules XML and search for matching schedule
    schedules_root = ET.fromstring(schedules_xml_string)
    schedule_elements = schedules_root.findall(f'.//{{{SI_NS}}}SCHEDULE')

    matching_schedule_str = None

    for sched in schedule_elements:
        sched_params = sched.find(f'{{{SI_NS}}}SCHEDULE_PARAMS')
        if sched_params is not None and sched_params.text:
            cdata_content = sched_params.text
            match = re.search(r'<ProducerMailbox>\s*<Value>(.*?)</Value>', cdata_content)
            if match:
                mailbox_value = match.group(1).strip()
                mailbox_id = mailbox_value.strip('/').split('/')[0]
                if mailbox_id == producer_id:
                    # Extract the raw XML string of this <SCHEDULE>
                    schedule_xml_bytes = ET.tostring(sched, encoding='unicode', method='xml')
                    matching_schedule_str = schedule_xml_bytes
                    break

    if not matching_schedule_str:
        raise ValueError("No matching schedule found for producer mailbox")

    # Clean injected XML: Remove XML declaration if present
    matching_schedule_str = re.sub(r'<\?xml.*?\?>', '', matching_schedule_str).strip()

    # Inject: locate <Consumers> and inject schedule as sibling
    insertion_point = re.search(r'(</Consumers>)', producer_xml_string)
    if not insertion_point:
        raise ValueError("No <Consumers> tag found in producer XML")

    inject_index = insertion_point.end()
    updated_xml = (
        producer_xml_string[:inject_index] +
        "\n  " + matching_schedule_str + "\n" +
        producer_xml_string[inject_index:]
    )

    # Pretty-print final XML
    reparsed = minidom.parseString(updated_xml.encode('utf-8'))
    pretty_xml = reparsed.toprettyxml(indent="  ")

    # Remove empty lines introduced by minidom
    pretty_xml = '\n'.join([line for line in pretty_xml.splitlines() if line.strip()])

    return pretty_xml
