import re
import xml.etree.ElementTree as ET
from xml.dom import minidom

def inject_schedule_for_producer(producer_xml_string: str, schedules_xml_string: str) -> str:
    # Step 1: Parse producer XML and find producer mailbox
    producer_tree = ET.ElementTree(ET.fromstring(producer_xml_string))
    ns = {'ns': producer_tree.getroot().tag.split('}')[0].strip('{')} if '}' in producer_tree.getroot().tag else {}
    producer_id_elem = producer_tree.find('.//ns:scux_USER_ID', ns) if ns else producer_tree.find('.//scux_USER_ID')
    if producer_id_elem is None or not producer_id_elem.text:
        raise ValueError("scux_USER_ID not found in producer XML.")
    producer_id = producer_id_elem.text.strip()

    # Step 2: Search for matching schedule
    schedule_match = None
    for match in re.finditer(r'<SCHEDULE>(.*?)</SCHEDULE>', schedules_xml_string, flags=re.DOTALL):
        schedule_block = match.group(0)

        # Extract inner CDATA from SCHEDULE_PARAMS
        params_match = re.search(r'<SCHEDULE_PARAMS><!\[CDATA\[(.*?)\]\]></SCHEDULE_PARAMS>', schedule_block, flags=re.DOTALL)
        if not params_match:
            continue
        dataxml = params_match.group(1)

        # Look for ProducerMailbox in DataXML
        mailbox_match = re.search(r'<Name>\s*ProducerMailbox\s*</Name>\s*<Value>\s*(.*?)\s*</Value>', dataxml)
        if mailbox_match and mailbox_match.group(1).strip() == producer_id:
            schedule_match = schedule_block
            break

    if not schedule_match:
        raise ValueError(f"No matching schedule found for producer ID {producer_id}")

    # Step 3: Preserve CDATA sections using placeholders
    cdata_placeholders = {}
    def cdata_replacer(m):
        tag = m.group(1)
        content = m.group(2)
        placeholder = f"__CDATA_PLACEHOLDER_{len(cdata_placeholders)}__"
        cdata_placeholders[placeholder] = f"<![CDATA[{content}]]>"
        return f"<{tag}>{placeholder}</{tag}>"

    cleaned_schedule = re.sub(
        r"<(\w+)><!\[CDATA\[(.*?)\]\]></\1>",
        cdata_replacer,
        schedule_match,
        flags=re.DOTALL
    )

    # Step 4: Pretty-print the cleaned <SCHEDULE>
    parsed_sched = minidom.parseString(cleaned_schedule)
    pretty_sched = parsed_sched.toprettyxml(indent="  ")
    pretty_sched = "\n".join(line for line in pretty_sched.splitlines() if not line.strip().startswith("<?xml"))
    pretty_sched = pretty_sched.strip()

    # Step 5: Restore CDATA blocks
    for placeholder, cdata_text in cdata_placeholders.items():
        pretty_sched = pretty_sched.replace(placeholder, cdata_text)

    # Step 6: Inject as sibling to <Consumers>
    # Find position of </Consumers> in the original XML string
    insert_pos = producer_xml_string.find("</Consumers>")
    if insert_pos == -1:
        raise ValueError("</Consumers> tag not found in producer XML.")

    insert_pos += len("</Consumers>")
    updated_xml = (
        producer_xml_string[:insert_pos] +
        "\n" +
        pretty_sched +
        producer_xml_string[insert_pos:]
    )

    return updated_xml
