import xml.etree.ElementTree as ET
import re

def inject_schedules(producer_xml_string, schedules_xml_string):
    # Parse producer XML to extract user ID
    try:
        producer_tree = ET.ElementTree(ET.fromstring(producer_xml_string))
    except ET.ParseError:
        return producer_xml_string  # return original if malformed

    producer_root = producer_tree.getroot()
    # Extract namespace (if any)
    match = re.match(r'\{(.*)\}', producer_root.tag)
    ns = {'ns': match.group(1)} if match else {}

    user_elem = producer_root.find('.//ns:scux_user_id', ns) if ns else producer_root.find('.//scux_user_id')
    if user_elem is None or not user_elem.text:
        return producer_xml_string

    producer_id = user_elem.text.strip()
    expected_mailbox = f"/{producer_id}"

    # Find all raw <SCHEDULE> blocks in the schedules XML
    schedule_blocks = re.findall(r"<SCHEDULE\b.*?</SCHEDULE>", schedules_xml_string, re.DOTALL)

    for sched in schedule_blocks:
        # Look for ProducerMailbox inside CDATA
        cdata_match = re.search(r"<SCHEDULE_PARAMS><!\[CDATA\[(.*?)\]\]></SCHEDULE_PARAMS>", sched, re.DOTALL)
        if not cdata_match:
            continue

        inner_xml = cdata_match.group(1)
        if f"<Name>ProducerMailbox</Name><Value>{expected_mailbox}</Value>" in inner_xml:
            # Match found â€” inject before last closing tag
            closing_tag_match = re.search(r"</\s*[^<>]+>\s*$", producer_xml_string)
            if closing_tag_match:
                insert_pos = closing_tag_match.start()
                return (
                    producer_xml_string[:insert_pos]
                    + sched + "\n"
                    + producer_xml_string[insert_pos:]
                )

    # If no match, return original
    return producer_xml_string
